# Домашнее задание к занятию "11.03 Микросервисы: подходы"

## Задача 1: Обеспечить разработку

Проаназировав полученные требования, я готов предложить рассмотреть вариант использования Gitlab. 

Он может использоваться как сервис версионного контроля исходного кода и конфигураций, как сервис управления репозиториями дистрибутивов благодаря возможности хранения артефактов / образов, как сервис управление планированием, требованиями, релизами и тестированием. Ко всему сказанному, он будет прост и удобен в управлении развертыванием и сборкой ПО.

Он может использоваться в облаке, как готовый сервис.

**Вариант использования:**

Сервис разворачивается в Yandex Cloud. При необходимости мы можем зарегистрировать дополнительные раннеры на отдельном сервере. 

Для проекта создается подгруппа, в подгруппе репозитории по микросервисам, для удобства разработки и эксплуатации.

Для разработчиков разбиваются роли, (пр. DevOps owner, TeamLead maintainer, Developer developer, tester guest). За счет этого, мы минимизируем риски связанные с безопасностью и разбиваем зоны ответственности. 

Для каждого из микросервиса мы настраиваем CI/CD в gitlab-ci.yml. 
Как пример, при пуше в ветку Develop мы собираем сервис, тестируем, сохраняем полученный артефакт/образ в gitlab и производим развертывание на Dev стенд, используя образ ansible/k8s. Секреты храним в Gitlab Variables.

При попытке мержа в Master ветку, тимлид проводит код ревью, мержит и имеет возможность мануально задеплоить сервис в прод.

**P.S.**

Шаблоны можно хранить в отдельном репозитории CI/CD templates и переиспользовать.

Несколько конфигураций мы можем использовать благодаря условиям в gitlab-ci и использованию шаблонов.

Собственные образы мы можем пушить/пуллить в GitLab Container Registry.

Параллельный запуск тестов возможен в рамках одного Stage, если результат их выполнения не зависит друг от друга.

## Задача 2: Логи

Для решения задачи сбора и анализа логов в микросервисной архитектуре я готов предложить ELK стек. 

1. Агент Filebeat собирает логи с stdout контейнеров и отправляет их в LogStash.
2. Для гарантированной доставки логов мы можем подключить к этому брокер сообщений (пр. Kafka)
3. В качестве поискового движка будет выступать Elastic, а для визуализвации логов будет выступать Kibana. 

Также, мы сможем разбить доступ к логам для разработчиков так, как необходимо.

Как альтернативу ELK стеку, готов предложить Grafana Loki.

## Задача 3: Мониторинг

Для решения задачи обеспечения сбора и анализа состояние хостов/сервисов предлагаю рассмотреть стек Grafana Prometheus. 

Благодаря нужным экспортерам (node exporter, cadvisor), мы сможем собирать метрики, необходимые нам, будь то состояние самой машины или частных контейнеров/подов. 

Дашборды могут быть настроены как своими силами, с набором только необходимых метрик, так и могут быть использованы готовые варианты, которых большое количество.

Также, мы можем легко настроить алертинг с помощью встроенного в новых версиях Grafan'ы Alertmanagera и можем интегрироваться с сервисом логирования.

Делать запросы, алертинг и настройку дашбордов позволяет синтаксис PromQL.